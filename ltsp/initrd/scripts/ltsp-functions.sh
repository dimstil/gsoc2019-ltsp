# This file is part of LTSP, https://ltsp.github.io
# Copyright 2019 the LTSP team, see AUTHORS
# SPDX-License-Identifier: GPL-3.0-or-later

# Sourced by LTSP initramfs scripts

# Source the ltsp.sh functions without any tools.
# We'll only use a few of them, like debug_shell, die etc.
LTSP_MAIN=true . /ltsp/ltsp.sh

if [ -f /scripts/functions ]; then
    # Running on initramfs-tools
    must . /scripts/functions
else
    # Running on dracut
    rootmnt=/sysroot
    # ROOT=/dev/nbd0?
fi

# TODO: fix comments and check if ltsp-client.sh should be sourced
# This hook is supposed to run after networking is configured and before root
# is mounted, in order to:
#  * Repair wrong networking, e.g. ProxyDHCP
#     - Meh, not needed with iPXE; only with syslinux/IPAPPEND 2
#     - Well it's needed when booting from grub/local kernel
#  * Evaluate IP/MAC/HOSTNAME sections of lts.conf
#  * Example: One could set SERVER=ip in lts.conf, to choose where nbd would connect!
# For initramfs tools, networking isn't yet configured, but it's OK to call
# configure_networking at this point.
# Now... in which cases do we want to run ltsp-client without networking?!
#  * Roaming laptop without networking. Local accounts AND home!
main_ltsp_premount() {
    warn "Starting $LTSP_TOOL"
    case "$ROOT" in
        /dev/nbd*)
            must patch_nbd
            ;;
        /dev/etherd/*)
            must configure_aoe
            ;;
    esac
}

# Make root writable using a tmpfs overlay and override init
main_ltsp_bottom() {
    local img

    warn "Starting $LTSP_TOOL"
    # debug_shell "BEGIN LTSP BOTTOM"
    img=${nfsroot##*/}
    must test -n "$img"
    ltsploop="$rootmnt/${ltsploap:-$img-flat.vmdk}"
    must test -f "$ltsploop"
    fstype=$(blkid -s TYPE -o value "$ltsploop")
    if [ -n "$fstype" ]; then
        must mount -o ro,noload -t "$fstype" "$ltsploop" "$rootmnt"
    else
        pttype=$(blkid -s PTTYPE -o value "$ltsploop")
        must test -n "$pttype"
        # In Ubuntu loop is built-in and /proc/cmdline needs: loop.max_part=9
        must modprobe loop max_part=9
        # Get the first available loop device; e.g. dracut already uses loop0
        loop=$(losetup -f)
        must losetup "$loop" "$ltsploop"
        # Jessie needs a 3.18+ kernel and this initramfs-tools hack:
        if grep -qs jessie /etc/os-release; then
            echo "init=${init:-/sbin/init}" >> /scripts/init-bottom/ORDER
        fi
        for partition in "$loop"p*; do
            test -e "$partition" || continue
            fstype=$(blkid -s TYPE -o value "$partition")
            test -n "$fstype" || continue
            if mount -o ro,noload -t "$fstype" "$partition" "$rootmnt"; then
                if [ -d "$rootmnt/proc" ]; then
                    warn "Successfully mounted $partition to $rootmnt"
                    break
                else
                    umount "$rootmnt"
                fi
            fi
        done
    fi
    is_writeable || must overlay_root
    printf "# Empty fstab generated by LTSP.\n" > "$rootmnt/etc/fstab"
    must override_init
    # debug_shell "END LTSP BOTTOM"
}

# TODO: call configure_networking; we'll need it anyway for getltscfg and sshfs
configure_aoe() {
    local i interfaces

    # Wait for the network interfaces to become available
    i=0
    while i=$((i+1)); do
        interfaces=$(ip -oneline link show | sed -n '/ether/s/[0-9 :]*\([^:]*\).*/\1/p')
        if [ -n "$interfaces" ]; then
            break
        elif [ $i -ge 10 ]; then
            # After a while, give a shell to the user in case he can fix it
            debug_shell "No network interfaces found"
            i=0
        else
            sleep 1
        fi
    done
    # For AoE to work, interfaces need to be up, but don't need IPs
    for i in $interfaces; do
        ip link set dev "$i" up
    done
    # Wait for a network interface to be up
    i=0
    while i=$((i+1)); do
        if ip -oneline link show up | grep -vw lo | grep -q LOWER_UP; then
            break
        elif [ $i -ge 4 ]; then
            # After a while, give a shell to the user in case he can fix it
            debug_shell "No network interfaces are up"
            i=0
        else
            sleep 1
        fi
    done
    modprobe aoe
    udevadm settle || true
}

is_writeable() {
    chroot "$rootmnt" /usr/bin/test -w / && return 0
    mount -o remount,rw "$rootmnt" || true
    chroot "$rootmnt" /usr/bin/test -w / && return 0
    return 1
}

modprobe_overlay() {
    grep -q overlay /proc/filesystems &&
        return 0
    modprobe overlay &&
        grep -q overlay /proc/filesystems &&
        return 0
    if [ -f "$rootmnt/lib/modules/$(uname -r)/kernel/fs/overlayfs/overlay.ko" ]; then
        must mv /lib/modules /lib/modules.real
        must ln -s "$rootmnt/lib/modules" /lib/modules
        must modprobe overlay
        must rm /lib/modules
        must mv /lib/modules.real /lib/modules
        grep -q overlay /proc/filesystems &&
            return 0
    fi
    return 1
}

overlay_root() {
    must modprobe_overlay
    must mkdir -p /run/initramfs/ltsp
    must mount -t tmpfs -o mode=0755 tmpfs /run/initramfs/ltsp
    must mkdir -p /run/initramfs/ltsp/up /run/initramfs/ltsp/work
    must mount -t overlay -o upperdir=/run/initramfs/ltsp/up,lowerdir=$rootmnt,workdir=/run/initramfs/ltsp/work overlay "$rootmnt"
    # Seen on 20190516 on stretch-mate-sch and bionic-minimal
    if run-init -n "$rootmnt" /sbin/init 2>&1 | grep -q console; then
        warn "$0 working around https://bugs.debian.org/811479"
        must mount --bind /dev "$rootmnt/dev"
    fi
}

override_init() {
    if false; then
        # We can't use /run as it's mounted noexec. Mount --bind over the real init!
        real_init=$(readlink -f "$rootmnt/sbin/init" || readlink "$rootmnt/sbin/init")
        cp -a /ltsp/init /dev/init-ltsp && mount --bind /dev/init-ltsp "$rootmnt/$real_init"
    elif false; then
        mount --bind /ltsp/init "$rootmnt/$real_init"
        # ΕΔΩ - OK this works; but I can't unmount it as it's busy;
        # but I can `mount --move` it over /dev/init-ltsp; so all fine!
    elif true; then
        must mv "$rootmnt/sbin/init" "$rootmnt/sbin/init.real"
        # ln -s /run/ltsp/init "$rootmnt/sbin/init"
        must cp /ltsp/init "$rootmnt/sbin/init"
    fi
    # Move ltsp to /run to make it available after pivot_root.
    # But initramfs-tools mounts /run with noexec; so use a symlink.
    must mv /ltsp /run/initramfs/ltsp/
    must ln -s initramfs/ltsp/ltsp /run/ltsp
}

patch_nbd() {
    # Work around https://github.com/NetworkBlockDevice/nbd/issues/87
    # and https://github.com/NetworkBlockDevice/nbd/issues/99
    if grep -qs 'systemd-mark$' /scripts/local-top/nbd; then
        must sed "s/systemd-mark$/& -b 512; blockdev --rereadpt \$nbdrootdev/" -i /scripts/local-top/nbd
    fi
}
